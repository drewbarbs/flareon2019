* General
All the challenges come in a .7z file with password "flare"

* 1 Memecat
zip password is "flare"

This is a .NET executable

The binary has two forms. Each with a validate function. The first one
clearly compares to "RAINBOW". The second XORs the text box value with
'A' and compares to a key. The input needs to be Bagel_Cannon to make
the match.

key:
#+begin_src text
Kitteh_save_galixy@flare-on.com
#+end_src

* 2 Overlong

radare2 immediately decodes the string:
#+begin_src text
I_a_M_t_h_e_e_n_C_o_D_i_n_g@flare-on.com
#+end_src

You just need to extend the length passed to the decoding function and
run the bin, that will also pritn the key.

* 3 Flarebear
Flag:
#+begin_src text
th4t_was_be4rly_a_chall3nge@flare-on.com
#+end_src

Used [[https://github.com/budtmo/docker-android][this]] emulator


It's an apk, so might need to get  an emulator goign?

Used dex2jar. See the FlareBearActivity has a getPassword function
that gives decryption key?

The isEcstatic function checks for mass of 72, happy of 30, clean of
false (0)


clean increments mass by 0, happy by -1, clean by 6
feed increments mass by 10, happy by 2, clean by -1
play increments mass by -2, happy by 4, clean by -1

Linear system:

#+begin_src python
import numpy as np
from numpy.linalg import inv

# First column corresponds to "clean",
# second to "feed", third to "play"
A = np.array([
    [0, 10, -2], # delta mass
    [-1, 2, 4],  # delta happy
    [6, -1, -1]])# delta clean

# target: 72 mass, 30 happy, 0 clean
b = np.array([
    [72],
    [30],
    [0]
    ])

print(inv(A) @ b)
#+end_src



8 * feed  = 80, 16, -8
8 * play  = -16

*need 2 cleans, 8 feeds, 4 plays*
* 4 DNSChess
Flag:

#+begin_src text
LooksLikeYouLockedUpTheLookupZ@flare-on.com
#+end_src


This is reportedly an ubuntu binary

We get a PCAP, a shared object, and an ELF

Looking at pcap first, I clearly see chess moves in queries, do
responses have moves as well?


Looks like the flag is xor'd 2 bytes at a time with the second byte of
the returned address.

Expecting game over in 15 moves.

The key is encoded in the return addresses for the DNS queries

The checks in =getNextMove= show you which responses you need to use in
what order.

First, the last octet of the IP address needs to be even. There are 15
such responses. Then, the last 4 bits of the second-to-last octet need
to be equal to the move number (this gives an ordering). The key byte
is composed of the second octet of those ips in that order. See =do.py=.

* 5 demo

Flag:

#+begin_src text
moar_poetry@flare-on.com
#+end_src

** Solution

Dump binary after it's been decrypted and is in render loop. Figure
out the binary creates /two/ meshes, and renders them with different
transforms. Figure one of them must be the flare logo, the other the
flag.

Do some patching in the =Update= function. NOP-out (replace with =add
esp, N= instructions) the =D3DXMatrixMultiply= and =SetTransform= calls
preceding draw of flag mesh. As well as NOP out logo mesh.

** Notes

Looks like the demo decrypts itself. It's got a single =rwx= section.

Unpacking to address 0x420000

Try setting breakpoint on load of user32:

#+begin_src text
sxe ld:user32.dll
#+end_src

Loaded by code in =0x420000= range. Where is that code written?

There's an =rcl= instruction at =400011= that updates that value. That's
/behind/ the entry point

#+begin_src text
bp 40000f
bp 400011
#+end_src

Difference in mappings at the beginning and after render loop is
happening:

before:

#+begin_src text
+   400000   401000     1000 MEM_IMAGE   MEM_COMMIT  PAGE_EXECUTE_READWRITE             Image      [image00400000; "image00400000"]
    401000   800000   3ff000 MEM_IMAGE   MEM_COMMIT  PAGE_EXECUTE_WRITECOPY             Image      [image00400000; "image00400000"]
    800000 1f83b6eb 1f03b6eb MEM_IMAGE   MEM_COMMIT  PAGE_EXECUTE_READWRITE             Image      [image00400000; "image00400000"]
#+end_src

at LoadLibrary of user32

#+begin_src text
+   400000   41f000    1f000 MEM_IMAGE   MEM_COMMIT  PAGE_EXECUTE_WRITECOPY             Image      [image00400000; "image00400000"]
    41f000 1f83b6eb 1f41c6eb MEM_IMAGE   MEM_COMMIT  PAGE_EXECUTE_READWRITE             Image      [image00400000; "image00400000"]
  1f83b6eb 1f83c000      915 MEM_IMAGE   MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [................]
#+end_src


at render loop:

#+begin_src text
+   400000   401000     1000 MEM_IMAGE   MEM_COMMIT  PAGE_EXECUTE_READWRITE             Image      [image00400000; "image00400000"]
    401000   41f000    1e000 MEM_IMAGE   MEM_COMMIT  PAGE_EXECUTE_WRITECOPY             Image      [image00400000; "image00400000"]
    41f000 1f83b6eb 1f41c6eb MEM_IMAGE   MEM_COMMIT  PAGE_EXECUTE_READWRITE             Image      [image00400000; "image00400000"]
#+end_src

Looks like a symbol table is being assembled at 430000.

After the demo is running we have

#+begin_src text
00430000  751f48d7 kernel32!LoadLibraryA
00430004  76ebd23e user32!CreateWindowExA
00430008  76ec4713 user32!GetAsyncKeyState
0043000c  76eb7d2f user32!GetSystemMetrics
00430010  76eb7f34 user32!GetWindowRect
00430014  76f0fdae user32!MessageBoxA
00430018  76eb8e4e user32!NtUserSetWindowPos
0043001c  71850a62 d3d9!Direct3DCreate9
00430020  73fa350b d3dx9_43!D3DXComputeNormals
00430024  73f98b4e d3dx9_43!D3DXCreateMeshFVF
00430028  73f628d9 d3dx9_43!D3DXMatrixLookAtLH
0043002c  73f60f00 d3dx9_43!D3DXMatrixMultiply
00430030  73f62bf3 d3dx9_43!D3DXMatrixPerspectiveFovLH
00430034  73f61afa d3dx9_43!D3DXMatrixRotationY
00430038  73f619df d3dx9_43!D3DXMatrixTranslation
#+end_src

Page at 430000 written at 4000c8

On entry to =420000=, pointer to PEB is on stack (so =pop eax= loads =pPEB=
into =eax=)

** TODO See how this is done quickly...
* 6 bmphide

Flag: (run =solve.py= on =image.bmp=, then /again/ on the BMP that extracts..)
#+begin_src text
d0nT_tRu$t_vEr1fy@flare-on.com
#+end_src

+Uses steghide? The binary is a .NET assembly+

Note that in .NET, args to Main /do not/ include name of the executable
file. [[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/hello-world-your-first-program][src]]

Usage is:
1st arg: path to bitmap
2nd arg: path to file to incorporate into image
3rd arg: path to output bitmap

Can't debug with dnSpy? I get a stack overflow
exception on start....

Through a combination of using windbg to break on
LoadLibrary/GetProcAddress and looking at =Program.IdentifyLocals= decompilation
in dnSpy, I figure out that =IdentifyLocals= is hooking =compileMethod=.
Pointer to original is saved in =A.originalDelegate=, replaced with
=A.IncrementMaxStack=, which will edit IL before compilation. This
causes stack overflow on debug as =compileMethod= is called to JIT the
=IncrementMaxStack= method...

The =Init= method swaps method pointers using [[https://stackoverflow.com/questions/39213674/c-sharp-changing-methods-pointers-net-3-5][this]] technique.

#+begin_src text
Program.a <- Program.b
Program.c <- Program.d
#+end_src

The =IdentifyLocals= function does some kind of changing of the calling
convention thing that ends up causing the overflow..

** Solve
Iterate over the image in /column major/ order, extract "transformed"
bytes.

Iterate over transformed bytes, reverse the conversion.

** Modifications

- Edit =a= to return =Program.b(b, r)=
- Edit =c= to return =Program.d(b, r)=
- Edit the IL of =h=:
  - write byte 20 (0x14) to offset 23 in IL (call to =Program.f= becomes call
    to =Program.g=)
  - write byte 20 (0x14) to offset 62 in IL (another kind of relative call ofset)
- Edit the IL of =g=:

  Changes the function body to be:

  #+begin_src java
public static byte g(int idx)
{
	byte b = (byte)((long)(idx + 1) * (long)((ulong)309030853));
	byte k = (byte)((idx + 2) * 209897853);
	return Program.e(b, k);
}
  #+end_src



  - write int32 309030853 to offset 6 in IL

    0x126b6fc5

    little endian: c5 6f 6b 12

  - write int32 209897853 to offset 18 in IL

    0xc82c97d

    little endian: 7d c9 82 0c


*I've verified that my modified executable produces image with the same
hash as the unmodified one.*


** =IdentifyLocals=

Calls =LoadLibraryA= with =clrjit.dll=

#+begin_src c
private unsafe static void IdentifyLocals()
		{
			ulong* ptr = stackalloc ulong[(UIntPtr)16];
			bool flag = A.ver4;
			if (flag)
			{
				,*ptr = 7218835248827755619UL; // ptr to string "clrjit.dll"
				ptr[1] = 27756UL;
			}
			else
			{
				,*ptr = 8388352820681864045UL;
				ptr[1] = 1819042862UL;
			}
			IntPtr lib = A.LoadLibrary(new string((sbyte*)ptr));
			,*ptr = 127995569530215UL; // ptr to string "getJit"
			A.getJit getJit = (A.getJit)Marshal.GetDelegateForFunctionPointer(A.GetProcAddress(lib, new string((sbyte*)ptr)), typeof(A.getJit));
			IntPtr jitVfTable = *getJit(); // clrjit!CILJit::`vftable'
			IntPtr pCompileMethod = *(IntPtr*)((void*)jitVfTable);
			bool flag2 = IntPtr.Size == 8;
			IntPtr pCompileMethodTrampoline;
			uint flNewProtect;
			if (flag2)
			{
				pCompileMethodTrampoline = Marshal.AllocHGlobal(16);
				ulong* ptr2 = (ulong*)((void*)pCompileMethodTrampoline);
				*ptr2 = 18446744073709533256UL;// mov rax, -1; jmp eax
				ptr2[1] = 10416984890032521215UL;
				A.VirtualProtect(pCompileMethodTrampoline, 12u, PAGE_EXECUTE_READWRITE, out flNewProtect);
				Marshal.WriteIntPtr(pCompileMethodTrampoline, 2, pCompileMethod);
			}
			else
			{
				pCompileMethodTrampoline = Marshal.AllocHGlobal(8);
				ulong* ptr3 = (ulong*)((void*)pCompileMethodTrampoline);
				*ptr3 = 10439625411221520312UL; // mov eax, -1; jmp eax
				A.VirtualProtect(pCompileMethodTrampoline, 7u, PAGE_EXECUTE_READWRITE, out flNewProtect);
				Marshal.WriteIntPtr(pCompileMethodTrampoline, 1, pCompileMethod); // write pointer at offset 1
			}
			A.originalDelegate = (A.locateNativeCallingConvention)Marshal.GetDelegateForFunctionPointer(pCompileMethodTrampoline, typeof(A.locateNativeCallingConvention));
			A.handler = new A.locateNativeCallingConvention(A.IncrementMaxStack);
			RuntimeHelpers.PrepareDelegate(A.originalDelegate);
			RuntimeHelpers.PrepareDelegate(A.handler);
			A.VirtualProtect(jitVfTable, (uint)IntPtr.Size, 64u, out flNewProtect);
			Marshal.WriteIntPtr(jitVfTable, Marshal.GetFunctionPointerForDelegate<A.locateNativeCallingConvention>(A.handler));
			A.VirtualProtect(jitVfTable, (uint)IntPtr.Size, flNewProtect, out flNewProtect);
		}
#+end_src

The clrjit vftable looks like this:

The IncrementMaxStack bit screws with the IL of the =Program.h= and
=Program.g= methods (can use dnSpy's right click->goto MD token feature
to quickly find that).

* 7 wopr

Flag:
#+begin_src text
L1n34R_4L93bR4_i5_FuN@flare-on.com
#+end_src


First step: remove the "dynamic base" characteristic using CFF explorer.

Looking through strings I see =PyUnicode=..., embedded python
interpreter?

Using Process Monitor I see it writes a bunch of stuff out to a folder
in =AppData\Local\Temp=.

Sets =_MEIPASS2=C:\Users\IEUser\AppData\Local\Temp\_MEI5602= ; this is
probably used as a signal pointing to where the stuff has been written?

Probably something to =this\key= in that temp folder

exec main script at 402160?

Look at =do_loadlib_python= in ghidra

Run =.childdbg= to enable tracing child process in windbg

Dump the marshalled code:

1. dump pymarshal_readobjectfromstring argument
2. Load in python with marshal.load

Turns out this loading a common bit of code from PyInstaller (lots of
google hits): pyiboot01_bootstrap.py

Loads:
-  pyiboot01_bootstrap.py
- pyiboot02_cleanup.py

Execution of pyiboot02_cleanup.py seems to be where the actual game
logic is (that PyEval call blocks...)

Dumped the 2nd code object, got source with uncompyle6:

#+begin_src python
import marshal
import uncompyle6

with open('boot2.bin', 'rb') as f:
    co = marshal.load(f)

with open('out.py', 'w') as out:
    uncompyle6.main.decompile(3.7, co, out)
#+end_src

*Break on lzma decode and dump when it succeeds?*

That gets =compressed.bin=, which we can =xzcat= to get the game

break on module load _lzma. then set conditional breakpoint:

#+begin_src text
bp _lzma+1e4f ".if (eax) {} .else {gc}"
#+end_src

Edit the source in memory to get it to print out what we compare to

#+begin_src text
.childdbg 1
g
sxe ld _lzma
bp _lzma+1e4f ".if (eax) {} .else {gc}"
s -a 0 L?80000000 "t.typewrite('GREETINGS"
# write at matches
ea <match> "exec('repr(h) is', repr(h)) #"
#+end_src

#+begin_src python
h = [115, 29, 32, 68, 106, 108, 89, 76, 21, 71, 78, 51, 75, 1, 55, 102]
#+end_src

Use =solve.py= to get solution

** Is it important to understand the structure passed to run_main?
Or can I just dump the python code object passed to pyeval evalcode
* 8 snake
This is the NES one

Flag:
#+begin_src text
NARPAS-SWORD@FLARE-ON.COM
#+end_src


** 6502 assembly
[[https://dwheeler.com/6502/oneelkruns/asm1step.html][6502 Assembly In One Step]]

Stack grows down from 0x1ff to 0x100

STA = store absolute (put accumulator in absolute address)

Little Endian for indirect absolute addressing

There is Indexed Indirect Addressing:
LDA ($B4,X)

and Indirect Indexed Addressing

LDA ($B4), Y

A <- 16 bit word at $B4 + Y

** Debugging w/ FCEUX
Can single-step through the beginning of ROM execution by checking the
"auto-open" button in FCEUX, adding a breakpoint at reset vector (the
symbolic address RST, see [[http://wiki.nesdev.com/w/index.php/FCEUX_debugger][tips]]) then reopening the ROM

https://wiki.nesdev.com/w/index.php/CHR_ROM_vs._CHR_RAM

"NES has at least two memory chips: PRG (connected to the CPU) and CHR
(connected to the PPU)". Cartridges may have CHR ROM or CHR RAM chips
to make tile data available to the PPU. CHR ROM is available to PPU
"from the moment it turns on"

We're dealing with an iNES header (not iNES2)

Header has a hard-wired "vertical [[https://wiki.nesdev.com/w/index.php/PPU_nametables][nametable]] mirroring"

A nametable is an area of memory used by the PPU to layout backgrounds.

NES resolution is 256x240

According to the header, and [[http://nesdev.com/neshdr20.txt][this]] document, the ROM has /no mapper/.

Writing to address $4017 ("[[https://wiki.nesdev.com/w/index.php/APU_Frame_Counter][APU frame counter]]")  is somewhat confusing.
We write 0x40, which sets the sequencer mode to 4-step sequence, 1 to
interrupt inhibit flag.

[[https://wiki.nesdev.com/w/index.php/Init_code][This]] helps with understanding the initial code in the ROM

** Loading
The PRG-ROM is loaded at $8000 /and/ at $C000 in the NES CPU memory
([[https://en.wikibooks.org/wiki/NES_Programming/Memory_Map][source]]). Note that this ends up mapping the NMI interrupt vector at
$FFFA to the 16 bit word at offset 0x400a ($10 + $3ffa == 0x400a) in
the ROM file, which is 0xc3f0.FCEUX treats $C000 as the entry point.

The CHR ROM is mapped at $0000 in the /PPU/ memory

Since PPUCTRL only has 0 or 0x90 written to it (bit 5 always clear), that means the sprite
size is 8x8.

Sprites are 16 bytes. 8x8 = 64 pixels * 2 bits per pixel = 128 bits.
Any pixel whose color is 0 is transparent/takes background color

Seems like flag at $002c indicates whether we are "in game"; I set a
write breakpoint on there and found that it was being written to by a
chunk of code not in the "main" chunk. Turns out it's the NMI handler
(which fires during vblank interval)

I was about to go full into reversing the rest of =main= and the NMI
handler. [[https://wiki.nesdev.com/w/index.php/NMI_thread][This]] seems like it might be an interesting read from a game
architecture perspective. However, I got the flag in a super easy way:

There was another =if= check in there for whether some other byte is set
to $F0. Setting that myself in the memory editor I see the flag
getting rendered.
* 9 reloadered
Flag

#+begin_src text
I_mUsT_h4vE_leFt_it_iN_mY_OthEr_p4nTs?!@flare-on.com
#+end_src


Strings suggest the function of interest is at =0xffff10d0=? This is a *troll*

I fell for the "roter hering" (red hering) because if you use angr on this
you get RoT3rHeRinG as the key.


*Seems like stuff goes down at 112d0... investigate this*

*Noticed that sometimes the binary takes longer, doesnt print messag*

The hint says there are issues with Ghidra. I finally try it, and see
it is choking on the relocations. Looking at the PE in CFF Explorer, I
see some peculiarities..

For one thing, there are multiple base relocation blocks for the page
at RVA 1000.

Sometimes the reloaderd.exe thing doesnt prompt. At those times, it
doesnt seem like the false key works?

There seem to be some actual relocations, and additional ones? At
least one relocation changes a code byte.

Also, there's a relocation directory for the page =.reloc= is located in!

Key insight was realizing that the relocations actually changed the
instructions of the intro code (ran before =main=, to branch differently
and execute some code at 112d0).

Let's look at how loader would process this PE...

1. Image wants to be loaded at 0xFFFF0000 (64K away from maximum 32
   bit address), =SizeOfImage= is 0x4c000 (304K),
   mainly because the relocation section is huge! Virtual size 45bb6,
   raw size 45c00

** TODO Write a ghidra script to detect when relocation changes /semantics/
Generally, relocations just change data offsets, but should be
possible to disassemble bin then determine when a relocation would
change the actual instruction.

** Next steps
*** Figure out how to get the binary to load in ghidra

** 12d0
[a8,b8) -> 160
[b8-c8) -> 150
[c8, d8) -> 140
[d8,dc) -> 130
[dc] -> 12c

So, intro BB copies 56 bytes from 132a8 (a contiguous block preceding
=@flare-on.com=) onto stack at =ebp-0x150=

Function ends up doing a bunch of time based stuff in the beginning,
which introduces some randomness. Under certain circumstances, a
different prompt appears (=Enter key=, without the reloadered intro
thing), and at that point there's an =fgets(buf, 14, stdin)=, which
means the input is at most 13 characters (last one may be a newline,
which would then subsequently be zerod out to make at most 12 chars).

Finally, we loop over the key, xor'ing it with the buffer at esp+0x70
= ebp-0x150, which is initialized with 0x38 bytes from 132a8, then
modified at 1156c

#+begin_src c
const uint8_t buffer[64] = {
  0x7a, 0x17, 0x08, 0x34, 0x17, 0x31, 0x3b, 0x25, 0x5b, 0x18,
  0x2e, 0x3a, 0x15, 0x56, 0x0e, 0x11, 0x3e, 0x0d, 0x11, 0x3b,
  0x24, 0x21, 0x31, 0x06, 0x3c, 0x26, 0x7c, 0x3c, 0x0d, 0x24,
  0x16, 0x3a, 0x14, 0x79, 0x01, 0x3a, 0x18, 0x5a, 0x58, 0x73,
  0x2e, 0x09, 0x00, 0x16, 0x00, 0x49, 0x22, 0x01, 0x40, 0x08,
  0x0a, 0x14, 0x00, 0x00, 0x00, 0x00, 0x70, 0xfd, 0x1d, 0x00,
  0x04, 0x00, 0x00, 0x00
};
#+end_src

If we xor (buffer[0x34-13:0x34], "@flare-on.com"), we get the code of
3HeadedMonkey, which reveals the flag

#+begin_src python
import itertools

buf = [
  0x7a, 0x17, 0x08, 0x34, 0x17, 0x31, 0x3b, 0x25, 0x5b, 0x18,
  0x2e, 0x3a, 0x15, 0x56, 0x0e, 0x11, 0x3e, 0x0d, 0x11, 0x3b,
  0x24, 0x21, 0x31, 0x06, 0x3c, 0x26, 0x7c, 0x3c, 0x0d, 0x24,
  0x16, 0x3a, 0x14, 0x79, 0x01, 0x3a, 0x18, 0x5a, 0x58, 0x73,
  0x2e, 0x09, 0x00, 0x16, 0x00, 0x49, 0x22, 0x01, 0x40, 0x08,
  0x0a, 0x14, 0x00, 0x00, 0x00, 0x00, 0x70, 0xfd, 0x1d, 0x00,
  0x04, 0x00, 0x00, 0x00
]

def xor(k, arr):
    return bytes(bytearray(kb ^ b for kb, b in zip(itertools.cycle(k), arr)))

key = xor(b'@flare-on.com', buf[0x34-13:0x34])
print(xor(key, buf))
#+end_src

* 10 Mugatu
Hints suggest there is some kind of key leakage across encrypted
samples. Reuse of IV or OTP?

Looking at the very first function called by =entry= (+which might very
well be a stock CRT function+ *NOPE*, it reverses the imported functions
from each module with 3 or more imports, screwing with IAT), I wanted
to remember what was up with the import descriptor table (array of one
IMAGE_IMPORT_DESCRIPTOR per imported dll), the import address table
(IAT, an array of IMAGE_THUNK_DATA that is populated as functions are
linked in. IMAGE_IMPORT_DESCRIPTOR FirstThunk member points to this),
and the import lookup table (aka import name table). Helpful
resources:

- https://stackoverflow.com/a/3801692/756104
- https://web.archive.org/web/20090413060054/http://msdn.microsoft.com/en-us/magazine/cc301808.aspx
- https://f3real.github.io/iat_hooking.html
- https://www.exploit-db.com/docs/english/18576-deep-dive-into-os-internals-with-windbg.pdf

I wrote a program to reverse the import name table entries in binary
so that Ghidra/IDA get the right function names. Figure out RVA to
file offset mapping

Ok, so the first actual thing the program does is get a "host id"
composed of a bunch of system parameters (username, IP addresses,
hostname, etc). Then, it fetches
http://twitrss.me/twitter_user_to_rss/?user=ACenterForAnts and XORs
the hostid with the first title in the response

The "title" ends up being

#+begin_src text
006b9276  49 26 23 78 32 37 3b 6d-20 64 6f 6e 65 2c 4a 61  I&#x27;m done,Ja
006b9286  63 6f 2e 20 49 20 67 6f-74 20 61 20 70 72 6f 73  co. I got a pros
006b9296  74 61 74 65 20 74 68 65-20 73 69 7a 65 20 6f 66  tate the size of
006b92a6  20 61 20 68 6f 6e 65 79-64 65 77 2e 2e 2e 61 6e   a honeydew...an
006b92b6  64 20 61 20 68 65 61 64-20 66 75 6c 6c 20 6f 66  d a head full of
006b92c6  20 62 61 64 20 6d 65 6d-6f 72 69 65 73 2e 00 2f   bad memories../
#+end_src

pubdate ends up being

#+begin_src text
Wed, 13 Dec 2017 16:55:37 +0000
#+end_src

Next, the app sends the xor'd hostid (base64'd) to
mugatu.flare-on.com, gets a base64 response back, which it decodes and
xor's the first 0x19 bytes of with 0x4d ('M')

=mugatu.flare-on.com= does not actually resolve

Is this decryption function at 402807 really only ever called with a
len of 0x19?. Probably not, looks like some code is =VirtualProtect='d
after the whole hostid thing

Need to stub out mugatu.flare-on.com.

1. Response needs to be greater than 0x3a
2. Needs to be base64 encoded
3. On the first go, we need the first 0x19 bytes of the response to be
   "orange mocha frappuccino\x00" XORd with 0x4d. Next 0x14 bytes are
   passed via mailslot to child, which writes them at offset (0x3c*2)
   on mailslot name in child
4. A thread is kicked off which waits on an event, then writes  0x14
   bytes  to =\\.\mailslot\Let_me_show_you_Derelicte=

Meanwhile, main thread continues to grab a couple bitmap resources.
One of which it "SRCINVERT"s (see call to =BitBlt=) to get a PE! This PE
is loaded and the main function creates a thread invoking its entry
point with a pointer to "CrazyPills" string.

The DLL has a bunch of obfuscation schemes, including flipped imports,
constructors that initialize strings, etc. Supposed to be named
=Derelicte.dll=? There's lots of coordination between threads using
events, mailslot

*TODO* look at function =1001000=

Encrypting logic compares against the constant string "really, really,
really, ridiculously good looking gifs". Seems to expect that is a
folder and encrypt only those gif

=__alldiv= instruction takes low, high parts of numerator and
denominator, returns =n / d= in =EDX:EAX=. /Does not/ give remainder. See [[https://stackoverflow.com/questions/9587742/what-is-alldiv][here]]

Have a XTEA looking algorithm to encrypt the blocks. Also note that
the key is only 4 bytes long! Given that knowledge, the filename
=the_key_to_success_0000.gif.Mugatu= makes sense: the file must have
been encrypted with the 4 byte key ={0, 0, 0, 0}=. So, we decrypt that
file and get a gif that tells us the first byte of the key is 0x31.
This might make it feasible to brute force
