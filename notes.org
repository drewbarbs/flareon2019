* General
All the challenges come in a .7z file with password "flare"

* 1 Memecat
zip password is "flare"

This is a .NET executable

The binary has two forms. Each with a validate function. The first one
clearly compares to "RAINBOW". The second XORs the text box value with
'A' and compares to a key. The input needs to be Bagel_Cannon to make
the match.

key:
#+begin_src text
Kitteh_save_galixy@flare-on.com
#+end_src

* 2 Overlong

radare2 immediately decodes the string:
#+begin_src text
I_a_M_t_h_e_e_n_C_o_D_i_n_g@flare-on.com
#+end_src

You just need to extend the length passed to the decoding function and
run the bin, that will also pritn the key.

* 3 Flarebear
Flag:
#+begin_src text
th4t_was_be4rly_a_chall3nge@flare-on.com
#+end_src

Used [[https://github.com/budtmo/docker-android][this]] emulator


It's an apk, so might need to get  an emulator goign?

Used dex2jar. See the FlareBearActivity has a getPassword function
that gives decryption key?

The isEcstatic function checks for mass of 72, happy of 30, clean of
false (0)


clean increments mass by 0, happy by -1, clean by 6
feed increments mass by 10, happy by 2, clean by -1
play increments mass by -2, happy by 4, clean by -1

Linear system:

#+begin_src python
import numpy as np
from numpy.linalg import inv

# First column corresponds to "clean",
# second to "feed", third to "play"
A = np.array([
    [0, 10, -2], # delta mass
    [-1, 2, 4],  # delta happy
    [6, -1, -1]])# delta clean

# target: 72 mass, 30 happy, 0 clean
b = np.array([
    [72],
    [30],
    [0]
    ])

print(inv(A) @ b)
#+end_src



8 * feed  = 80, 16, -8
8 * play  = -16

*need 2 cleans, 8 feeds, 4 plays*
* 4 DNSChess
Flag:

#+begin_src text
LooksLikeYouLockedUpTheLookupZ@flare-on.com
#+end_src


This is reportedly an ubuntu binary

We get a PCAP, a shared object, and an ELF

Looking at pcap first, I clearly see chess moves in queries, do
responses have moves as well?


Looks like the flag is xor'd 2 bytes at a time with the second byte of
the returned address.

Expecting game over in 15 moves.

The key is encoded in the return addresses for the DNS queries

The checks in =getNextMove= show you which responses you need to use in
what order.

First, the last octet of the IP address needs to be even. There are 15
such responses. Then, the last 4 bits of the second-to-last octet need
to be equal to the move number (this gives an ordering). The key byte
is composed of the second octet of those ips in that order. See =do.py=.

* 5 demo

Flag:

#+begin_src text
moar_poetry@flare-on.com
#+end_src

** Solution

Dump binary after it's been decrypted and is in render loop. Figure
out the binary creates /two/ meshes, and renders them with different
transforms. Figure one of them must be the flare logo, the other the
flag.

Do some patching in the =Update= function. NOP-out (replace with =add
esp, N= instructions) the =D3DXMatrixMultiply= and =SetTransform= calls
preceding draw of flag mesh. As well as NOP out logo mesh.

** Notes

Looks like the demo decrypts itself. It's got a single =rwx= section.

Unpacking to address 0x420000

Try setting breakpoint on load of user32:

#+begin_src text
sxe ld:user32.dll
#+end_src

Loaded by code in =0x420000= range. Where is that code written?

There's an =rcl= instruction at =400011= that updates that value. That's
/behind/ the entry point

#+begin_src text
bp 40000f
bp 400011
#+end_src

Difference in mappings at the beginning and after render loop is
happening:

before:

#+begin_src text
+   400000   401000     1000 MEM_IMAGE   MEM_COMMIT  PAGE_EXECUTE_READWRITE             Image      [image00400000; "image00400000"]
    401000   800000   3ff000 MEM_IMAGE   MEM_COMMIT  PAGE_EXECUTE_WRITECOPY             Image      [image00400000; "image00400000"]
    800000 1f83b6eb 1f03b6eb MEM_IMAGE   MEM_COMMIT  PAGE_EXECUTE_READWRITE             Image      [image00400000; "image00400000"]
#+end_src

at LoadLibrary of user32

#+begin_src text
+   400000   41f000    1f000 MEM_IMAGE   MEM_COMMIT  PAGE_EXECUTE_WRITECOPY             Image      [image00400000; "image00400000"]
    41f000 1f83b6eb 1f41c6eb MEM_IMAGE   MEM_COMMIT  PAGE_EXECUTE_READWRITE             Image      [image00400000; "image00400000"]
  1f83b6eb 1f83c000      915 MEM_IMAGE   MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [................]
#+end_src


at render loop:

#+begin_src text
+   400000   401000     1000 MEM_IMAGE   MEM_COMMIT  PAGE_EXECUTE_READWRITE             Image      [image00400000; "image00400000"]
    401000   41f000    1e000 MEM_IMAGE   MEM_COMMIT  PAGE_EXECUTE_WRITECOPY             Image      [image00400000; "image00400000"]
    41f000 1f83b6eb 1f41c6eb MEM_IMAGE   MEM_COMMIT  PAGE_EXECUTE_READWRITE             Image      [image00400000; "image00400000"]
#+end_src

Looks like a symbol table is being assembled at 430000.

After the demo is running we have

#+begin_src text
00430000  751f48d7 kernel32!LoadLibraryA
00430004  76ebd23e user32!CreateWindowExA
00430008  76ec4713 user32!GetAsyncKeyState
0043000c  76eb7d2f user32!GetSystemMetrics
00430010  76eb7f34 user32!GetWindowRect
00430014  76f0fdae user32!MessageBoxA
00430018  76eb8e4e user32!NtUserSetWindowPos
0043001c  71850a62 d3d9!Direct3DCreate9
00430020  73fa350b d3dx9_43!D3DXComputeNormals
00430024  73f98b4e d3dx9_43!D3DXCreateMeshFVF
00430028  73f628d9 d3dx9_43!D3DXMatrixLookAtLH
0043002c  73f60f00 d3dx9_43!D3DXMatrixMultiply
00430030  73f62bf3 d3dx9_43!D3DXMatrixPerspectiveFovLH
00430034  73f61afa d3dx9_43!D3DXMatrixRotationY
00430038  73f619df d3dx9_43!D3DXMatrixTranslation
#+end_src

Page at 430000 written at 4000c8

On entry to =420000=, pointer to PEB is on stack (so =pop eax= loads =pPEB=
into =eax=)

** TODO See how this is done quickly...
* 6 bmphide

Flag: (run =solve.py= on =image.bmp=, then /again/ on the BMP that extracts..)
#+begin_src text
d0nT_tRu$t_vEr1fy@flare-on.com
#+end_src

+Uses steghide? The binary is a .NET assembly+

Note that in .NET, args to Main /do not/ include name of the executable
file. [[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/hello-world-your-first-program][src]]

Usage is:
1st arg: path to bitmap
2nd arg: path to file to incorporate into image
3rd arg: path to output bitmap

Can't debug with dnSpy? I get a stack overflow
exception on start....

Through a combination of using windbg to break on
LoadLibrary/GetProcAddress and looking at =Program.IdentifyLocals= decompilation
in dnSpy, I figure out that =IdentifyLocals= is hooking =compileMethod=.
Pointer to original is saved in =A.originalDelegate=, replaced with
=A.IncrementMaxStack=, which will edit IL before compilation. This
causes stack overflow on debug as =compileMethod= is called to JIT the
=IncrementMaxStack= method...

The =Init= method swaps method pointers using [[https://stackoverflow.com/questions/39213674/c-sharp-changing-methods-pointers-net-3-5][this]] technique.

#+begin_src text
Program.a <- Program.b
Program.c <- Program.d
#+end_src

The =IdentifyLocals= function does some kind of changing of the calling
convention thing that ends up causing the overflow..

** Solve
Iterate over the image in /column major/ order, extract "transformed"
bytes.

Iterate over transformed bytes, reverse the conversion.

** Modifications

- Edit =a= to return =Program.b(b, r)=
- Edit =c= to return =Program.d(b, r)=
- Edit the IL of =h=:
  - write byte 20 (0x14) to offset 23 in IL (call to =Program.f= becomes call
    to =Program.g=)
  - write byte 20 (0x14) to offset 62 in IL (another kind of relative call ofset)
- Edit the IL of =g=:

  Changes the function body to be:

  #+begin_src java
public static byte g(int idx)
{
	byte b = (byte)((long)(idx + 1) * (long)((ulong)309030853));
	byte k = (byte)((idx + 2) * 209897853);
	return Program.e(b, k);
}
  #+end_src



  - write int32 309030853 to offset 6 in IL

    0x126b6fc5

    little endian: c5 6f 6b 12

  - write int32 209897853 to offset 18 in IL

    0xc82c97d

    little endian: 7d c9 82 0c


*I've verified that my modified executable produces image with the same
hash as the unmodified one.*


** =IdentifyLocals=

Calls =LoadLibraryA= with =clrjit.dll=

#+begin_src c
private unsafe static void IdentifyLocals()
		{
			ulong* ptr = stackalloc ulong[(UIntPtr)16];
			bool flag = A.ver4;
			if (flag)
			{
				,*ptr = 7218835248827755619UL; // ptr to string "clrjit.dll"
				ptr[1] = 27756UL;
			}
			else
			{
				,*ptr = 8388352820681864045UL;
				ptr[1] = 1819042862UL;
			}
			IntPtr lib = A.LoadLibrary(new string((sbyte*)ptr));
			,*ptr = 127995569530215UL; // ptr to string "getJit"
			A.getJit getJit = (A.getJit)Marshal.GetDelegateForFunctionPointer(A.GetProcAddress(lib, new string((sbyte*)ptr)), typeof(A.getJit));
			IntPtr jitVfTable = *getJit(); // clrjit!CILJit::`vftable'
			IntPtr pCompileMethod = *(IntPtr*)((void*)jitVfTable);
			bool flag2 = IntPtr.Size == 8;
			IntPtr pCompileMethodTrampoline;
			uint flNewProtect;
			if (flag2)
			{
				pCompileMethodTrampoline = Marshal.AllocHGlobal(16);
				ulong* ptr2 = (ulong*)((void*)pCompileMethodTrampoline);
				*ptr2 = 18446744073709533256UL;// mov rax, -1; jmp eax
				ptr2[1] = 10416984890032521215UL;
				A.VirtualProtect(pCompileMethodTrampoline, 12u, PAGE_EXECUTE_READWRITE, out flNewProtect);
				Marshal.WriteIntPtr(pCompileMethodTrampoline, 2, pCompileMethod);
			}
			else
			{
				pCompileMethodTrampoline = Marshal.AllocHGlobal(8);
				ulong* ptr3 = (ulong*)((void*)pCompileMethodTrampoline);
				*ptr3 = 10439625411221520312UL; // mov eax, -1; jmp eax
				A.VirtualProtect(pCompileMethodTrampoline, 7u, PAGE_EXECUTE_READWRITE, out flNewProtect);
				Marshal.WriteIntPtr(pCompileMethodTrampoline, 1, pCompileMethod); // write pointer at offset 1
			}
			A.originalDelegate = (A.locateNativeCallingConvention)Marshal.GetDelegateForFunctionPointer(pCompileMethodTrampoline, typeof(A.locateNativeCallingConvention));
			A.handler = new A.locateNativeCallingConvention(A.IncrementMaxStack);
			RuntimeHelpers.PrepareDelegate(A.originalDelegate);
			RuntimeHelpers.PrepareDelegate(A.handler);
			A.VirtualProtect(jitVfTable, (uint)IntPtr.Size, 64u, out flNewProtect);
			Marshal.WriteIntPtr(jitVfTable, Marshal.GetFunctionPointerForDelegate<A.locateNativeCallingConvention>(A.handler));
			A.VirtualProtect(jitVfTable, (uint)IntPtr.Size, flNewProtect, out flNewProtect);
		}
#+end_src

The clrjit vftable looks like this:

The IncrementMaxStack bit screws with the IL of the =Program.h= and
=Program.g= methods (can use dnSpy's right click->goto MD token feature
to quickly find that).

* 7 wopr
